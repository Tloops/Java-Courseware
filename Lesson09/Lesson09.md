# Lesson 09 - 静态方法

假设我们要判断一个数是否是一个质数，你会直接将代码写出来，可能需要花上将近十行代码。但是假设你在做一个大型的project，在这个project中你要不停地判断新接收到的数是否是质数，要判断几十多次，这个时候，你如果直接将判断写在程序里，那就是得几百多行。是否有一种方法，可以将一部分操作相同的代码组合到一起呢？这就要讲到我们这节课的内容——方法。



## 1 定义

**方法（Method）**是为完成一个操作而组合在一起的语句组。

方法就像一个流水线，为了设计一个流水线，需要明确以下几个内容：

1. 流水线需要什么**零件**
2. 这些零件应该**如何组装**到一起
3. 最后的**产品**是什么

依此类推，设计一个方法所需要的内容则为：

1. 方法接收什么**输入**
2. 对这些输入应该**如何处理**
3. 最后**输出**的结果是什么

在你有了这些“流水线”后，每次你想要某个操作的结果，只需要去定义一个相应的“流水线”，再每次直接使用这个”流水线“就可以了。



## 2 方法的声明

那么就让我们来看看怎么声明一个方法：

```java
public static int max(int num1, int num2) {
    if(num1 > num2)	return num1;
    else			return num2;
}
```

上面的代码声明了一个名叫`max`的方法，这个方法可以求出两个数中最大值并作为返回值返回出来。这样我们每次需要取两个整数的最大值时，都可以使用这个方法。

让我们一起从上往下深入地剖析一下这个方法的每一个部分：

- `public`：这个是**可见性修饰符（Access Modifiers）**，等到以后学到了其他的可见性修饰符再细说吧
- `static`：**静态修饰符**，表示这个方法是一个静态方法，等我们以后学到了实例方法再做分析吧
- `int`：写在方法名前面的类型表示这个方法的**返回值类型（return type）**，这里表示这个方法返回一个`int`类型的变量。什么是返回值呢？其实就是一个方法的运行结果，就像1+1运行结果是2一样
- `max`：**方法的名字**，我们需要用这个名字去区分要调用的方法
- `(int num1, int num2)`：**参数列表**，这里表示我们要接受两个`int`类型的参数，接收到的数据被复制后将存放在`num1`和`num2`这两个变量中，之后方法体内的语句想要使用输入的参数就直接使用这两个变量即可
- `line 2、3`：**方法体（method body）**，定义了这个方法内具体要进行的逻辑操作；我们这里是判断`num1`和`num2`的大小，最后返回大的那一个
- `return xxx`：通过`return`关键词**指明要返回的值**，当方法执行到return后会立刻结束，带着返回值回到调用这个方法的地方继续往后执行



### void

方法其实不一定非要有一个返回值，比如一个只是可以将一些数据漂漂亮亮地输出出来的方法：

```java
public static ? printGrade(String name, String studentID, double grade) {
    System.out.printf("     Name: %8s\n", name);
    System.out.printf("StudentID: %8s\n", studentID);
    System.out.printf("    Grade: %8.1f\n", grade);
}
```

这个时候你应该将这个方法的返回值类型声明为`void`。**void**英文本义为虚空的，在这里**表示一个方法什么也不返回**。如果你想要提前结束一个返回值为**void**的方法，可以直接使用`return;`。



## 3 方法的调用

我们刚刚声明了一个叫`max`的方法，但是我们该怎么去**调用**（**invoke**，计算机术语，使用的意思）这个方法呢？调用之后又进行了怎么样的过程呢？

```java
int i = 28, j = 23;
int k = max(i, j);
```

上面代码块的第二行就调用了`max`方法，我们使用方法名加上一个小括号，括号内是要传递给方法内部的一些参数。

当程序运行到第二行时，程序发现此处等号右边在调用`max`方法，就会继续去执行这个方法里的语句。同时，入参的`i`和`j`的数据值会被**复制**给方法内的`num1`和`num2`两个变量。最终，经过`max`方法的一番操作，较大的值被返回出来，作为`max(i, j)`的结果赋值给了`k`。

注意：这里的传参过程进行的是数据值的**复制**，所以无论我们怎么改变方法内的`num1`和`num2`，方法外的变量`i`和`j`不会有任何改变。



## 4 main方法

终于学到了这一节，让我们来重新认识一下我们的老朋友：**main方法**。

```java
public static void main(String[] args) {
    ...
}
```

深入剖析，我们发现main方法……

1. 全世界可见（public）
2. 静态方法（static）
3. **不返回值**（void）
4. 方法名为main（不是废话么:sweat_smile:）
5. 接收的参数为String类型的名为`args`的**一维数组**：这个就是之前学到的使用Arguments入参作为输入的承载体喔~



## 5 为什么我们要使用方法

1. **增加代码的复用性**：类似这篇课件开头的例子，当我们将判断质数的代码放在一个入参为待测数，返回值为是否是质数的方法中。每次我们**直接调用**这个方法而不是再写一遍判断质数的代码，这大大减少了代码的长度。
2. **易于debug**：由于每次调用方法，我们都使用的是同一块代码。这块代码如果出现了逻辑错误，我们可以**一次性地**、通过修改这块代码的内容来解决问题。但若我们将其分开，每次都再写一遍判断质数的代码，假设后来你发现你的代码有问题，比如大于符号和小于符号写反了，你就需要在你长长的代码中找到你在哪些地方写了这个判断，你要保证每一个你都有改正，可一不小心你就会改漏。
3. **模块化代码**：其实很多时候我们并不一定是为了减少重复的代码，我们也可能只是**将步骤繁复的代码分成多步**，分到好几个方法内。比如想象`makeMove`方法是你需要写的一个黑白棋（今年JavaA的project）人机代码：

```java
public static void makeMove(){
    searchValidPlaces();
    comparePlaces();
    makeBestMove();
    updateChessBoard();
}
```

​		我们将逻辑分布在四个方法里面，每个方法做相应的操作：开始我们先选哪里可以下，再比较可以下的地方下哪里最好，之后我们下最好的那一步，最后更新棋盘。这些的具体逻辑我们放在这些新的四个方法里面一一实现，这使得将一个复杂的逻辑分布，划开界限：一方面非常容易debug，你可以立刻找到哪里是你写的什么代码；另一方面你可以专注于一个小方法的实现，即一部分子逻辑的实现中。



## 6 方法重载

